# Aplica√ß√£o Server-Side üñ•

Neste documento, apresentaremos uma aplica√ß√£o server-side no padr√£o MVC (Model-View-Controller) que utiliza tokens web para a seguran√ßa dos endpoints. O objetivo deste trabalho √© adquirir conhecimento sobre APIs e aprimorar as linguagens e tecnologias utilizadas no desenvolvimento.

## Tecnologias Utilizadas ü§ñ
<div style="display: inline_block"><br/>

- <img align="center" alt="Node.js" src="https://img.shields.io/badge/Node.js-43853D?style=for-the-badge&logo=node.js&logoColor=white"/>
</b>

- <img align="center" alt="Sequelize" src="https://img.shields.io/badge/sequelize-323330?style=for-the-badge&logo=sequelize&logoColor=blue"/>
</b>

- <img align="center" alt="Json Web Token" src="https://img.shields.io/badge/json%20web%20tokens-323330?style=for-the-badge&logo=json-web-tokens&logoColor=pink"/> 
</b>

- <img align="center" alt="Express.js" src="https://img.shields.io/badge/Express.js-404D59?style=for-the-badge"/>
</b>

- <img align="center" alt="Express.js" src="https://img.shields.io/badge/MySQL-00000F?style=for-the-badge&logo=mysql&logoColor=white"/>
</b>


## Download üöÄ

Antes de dar inicio a nossa API precisamos baixar o Node.js.

https://nodejs.org/en

## Pr√©-Requisitos üìã

Agora que voc√™ tem o Node.js instalado, vamos criar quatro pastas importantes para a estrutura da nossa aplica√ß√£o. Essas pastas s√£o: **"Config"**, **"Controller"**, **"Models"** e **"Routes"**. 


## Inicio üëª

Ap√≥s configurar seu projeto, precisamos instalar as bibliotecas/frameworks que ser√£o utilizadas no desenvolvimento da nossa API. No terminal do Visual Studio Code, insira o comando abaixo:

````
npm install sequelize mysql2 jsonwebtoken express dotenv-safe body-parser --save
````
Verifique no arquivo "package.json" se todos foram instalados com sucesso. Al√©m disso, como iremos trabalhar com modulos adicione o "type": "module". Segue a imagem de exemplo.


![image](https://github.com/Pellegr1n1/Server-Side/assets/119978954/de619a50-4315-4e4a-a621-7e2143707774)



## Config ‚öôÔ∏è

Na pasta "Config", voc√™ pode criar arquivos .js para armazenar configura√ß√µes e informa√ß√µes relacionadas √† sua aplica√ß√£o. Iremos utilizar um arquivo .js para armazenar a configura√ß√µes de banco de dados. 

````
import { Sequelize } from "sequelize"

const db = new Sequelize('(DataBase)', '(User)', '(Password)', {
    host: 'localhost',
    dialect: 'mysql'
})
export default db
````
- Neste exemplo, estou estabelecendo a conex√£o com o banco de dados MySQL utilizando o Sequelize. Na fun√ß√£o Sequelize passo tr√™s argumentos: (DataBase), (User) e (Password). Esses argumentos representam as informa√ß√µes necess√°rias para a conex√£o com o banco de dados MySQL.

**Lembre-se de criar um banco de dados com o mesmo nome informado no c√≥digo. N√£o √© necess√°rio criar as tabelas por meio de SQL, pois iremos utilizar um m√©todo do Sequelize para isso.**

## Conex√£o com o servidor üåê

Agora voc√™ pode criar um arquivo chamado "server.js" para implementar a conex√£o com a porta e as rotas em sua aplica√ß√£o. O arquivo "server.js" servir√° como ponto de entrada para o seu servidor. 

````
import express from 'express'
import db from './Config/database.js'

const server = express()

server.use(express.json())
server.use(express.urlencoded({ extended: true }))

// Sincroniza os modelos com o banco de dados
db.sync({ alter: true }).then(() => {
	console.log("Tabelas criadas no banco de dados")
}).catch(error => {
	console.error("Erro ao sincronizar os modelos com o banco de dados:", error)
});
server.listen(3000, function () {
	console.log('Sevidor rodando na porta 3000')
});
````
- Note que neste c√≥digo, estou implementando a conex√£o com a porta 3000. Al√©m disso, utilizo a fun√ß√£o "sync" do Sequelize para criar ou alterar as tabelas de acordo com os modelos definido na pasta [Models](https://github.com/Pellegr1n1/Server-Side#models-).
  
**Obs.: Para o m√©todo "sync" funcionar, voc√™ precisa ter criado todos os modelos necess√°rios para a sua aplica√ß√£o.**

## Models üé≤
Na pasta "Models", voc√™ pode criar arquivos .js para definir os modelos da sua aplica√ß√£o. Esses arquivos ser√£o respons√°veis por descrever a estrutura das tabelas do banco de dados e definir as rela√ß√µes entre elas. 

- No exemplo a seguir, estou importando o m√≥dulo "db" da pasta "Config", que representa o banco de dados, e o m√≥dulo "Sequelize" para facilitar a cria√ß√£o e defini√ß√£o dos modelos do banco de dados. Utilizo o m√©todo **"define"** do Sequelize para criar a tabela, juntamente com seus respectivos campos.
````
import { Sequelize } from "sequelize";
import db from "../Config/database.js";

const Cliente = db.define("tbl_usuario", {
    usuario: {
        type: Sequelize.STRING(50),
        primaryKey: true,
        allowNull: false
    },
    senha: {
        type: Sequelize.STRING(20),
        allowNull: false
    }
},
    {
        timestamps: false, //Evita o registro de data/horario nas tabelas do banco
        freezeTableName: true, //Evita a pluraliza√ß√£o dos nomes
    }
)

export default Cliente
````
Caso voc√™ precise estabelecer relacionamentos entre tabelas usando chaves estrangeiras, uma abordagem comum √© utilizar a fun√ß√£o belongsTo para definir o relacionamento no seu c√≥digo. 

- Lembre-se de criar mais um campo na sua tabela e adicionar a referencia para estabelecer o relacionamento.
````
(nome_do_campo): {
  type: Sequelize.INTEGER,
  allowNull: false,
  references: {
    model: (nome_do_modelo),
    key: "(nome_da_chave)",
  },
},
````

Ao utilizar o **belongsTo**, voc√™ pode especificar o modelo relacionado e a chave estrangeira correspondente. Dessa forma, o Sequelize entender√° a associa√ß√£o entre os modelos e permitir√° que voc√™ acesse os registros relacionados.

````
Pet.belongsTo(Tutor, { foreignKey: "cpf" })
````

Nesse exemplo indica que um "Pet" pertence a um "Tutor" e a chave estrangeira utilizada para essa associa√ß√£o √© a coluna "cpf" da tabela "Tutor"


## Controller üéÆ

Na pasta "Controller", crie um arquivo .js para implementar o controle das funcionalidades da aplica√ß√£o. Este arquivo ser√° respons√°vel por receber as requisi√ß√µes dos clientes e coordenar as a√ß√µes necess√°rias.

### Tokens üîí

Lembre-se de que estamos utilizando tokens de autentica√ß√£o baseados em web tokens (JWT) para a nossa aplica√ß√£o. Para implementar essa funcionalidade, voc√™ pode seguir o exemplo abaixo:

- Observe que, ao utilizar o Sequelize para a cria√ß√£o das tabelas, voc√™ pode aproveitar as fun√ß√µes fornecidas por essa biblioteca, como: **"create"**, **"findAll"**, **"destroy"**, **"update"** dentre outras.
- N√£o se esque√ßa de criar uma variavel ambiente com um **SECRET** a seu crit√©rio. Estou utilizando ".env.example" como nome do arquivo.

No exemplo abaixo, estou enviando o token logo ap√≥s a cria√ß√£o de um usu√°rio.
````
import Cliente from "../Models/usuario_models.js"
import jwt from "jsonwebtoken"
import { config } from 'dotenv-safe'

config({ path: '.env.example' })

const createUsuario = async (req, res) => {
    try {
        const { usuario, senha } = req.body
        if (!usuario || !senha) {
            return res.status(422).json({
                msg: "Todos os campos devem estar preenchidos!"
            })
        }
        const valida = await Cliente.findByPk(usuario)

        if (valida) {
            return res.status(409).json({
                msg: "Usuario existente!"
            })
        } else {
            const user = await Cliente.create(req.body)
            const token = jwt.sign({ usuario }, process.env.SECRET, {
                expiresIn: 300
            })
            return res.status(200).json({
                user,
                auth: true,
                token,
                msg: "Usuario criado com sucesso!"
            })
        }
    } catch (e) {
        console.log("Error : ", e)
        return res.status(500).json({
            msg: "Ocorreu um erro ao criar o usuario"
        })
    }
}
````
Note que estou utilizando as bibliotecas:

- "Cliente" que √© respons√°vel pelo cadastro de usu√°rios;
- "jsonwebtoken" que √© usada para trabalhar com JSON Web Tokens (JWT)
- "dotenv-safe" que √© utilizada para carregar vari√°veis de ambiente de forma segura a partir de um arquivo .env.
  
Neste c√≥digo, estou criando um usu√°rio e realizando as devidas valida√ß√µes. Se todas as valida√ß√µes forem aprovadas, gero um token de autentica√ß√£o utilizando o m√©todo "sign" do JSON Web Token. Esse m√©todo requer um payload, que neste caso √© o usu√°rio, e um segredo (secret) para aumentar a seguran√ßa do token.

Ap√≥s gerar o token, √© necess√°rio validar o mesmo para aumentar a seguran√ßa. 

````
function verifyJWT(req, res, next) {
  const token = req.headers['x-access-token']
  jwt.verify(token, process.env.SECRET, (err, decoded) => {
    if (err) {
      return res.status(401).json({
        msg: "Token inv√°lido"
      })
    }
    req.userId = decoded.usuario
    next()
  })
}
````
Neste exemplo de c√≥digo, estou definindo a fun√ß√£o verifyJWT como um middleware para verificar a validade do meu token de acesso. Al√©m disso, decodifico o token para obter informa√ß√µes do usu√°rio autenticado, permitindo o prosseguimento da requisi√ß√£o apenas se o token for v√°lido.

- Middleware: Um middleware √© uma fun√ß√£o que √© executada no meio do processamento de uma requisi√ß√£o HTTP, permitindo realizar a√ß√µes antes ou depois de uma determinada rota ou fun√ß√£o ser executada.

Agora precisamos implementar um m√©todo que, ao acessar o endpoint passando o usu√°rio como par√¢metro, ele busca os dados desse usu√°rio apenas se o token for v√°lido para o mesmo. 

````
const getClienteByUser = async (req, res) => {
  try {
    const userId = req.userId

    // Verifica se o token gerado √© do usuario que esta tentando acessar
    if (req.params.user !== userId) {
      return res.status(403).json({
        msg: "Acesso n√£o autorizado"
      })
    }

    const getUser = await Cliente.findByPk(req.params.user)
    
    if (!getUser) {
      return res.status(404).json({
        msg: 'O usu√°rio n√£o foi encontrado'
      })
    }

    return res.status(200).json({
      getUser
    })
  } catch (e) {
    console.log("Erro: ", e)
    return res.status(500).json({
      msg: "Ocorreu um erro ao acessar os usu√°rios"
    })
  }
}
````

- Note que na minha fun√ß√£o "verifyJWT", eu decodifico o usu√°rio e passo-o para a vari√°vel "userId". Neste trecho de c√≥digo, para verificar se o token pertence ao usu√°rio, eu adiciono uma condi√ß√£o em que, se o par√¢metro passado na URL for diferente de "userId", o acesso n√£o √© autorizado. Caso contr√°rio, o restante do c√≥digo √© executado.

## Routes ‚úàÔ∏è
 
Na pasta "Routes", voc√™ pode criar arquivos .js para definir as rotas da sua aplica√ß√£o. Esses arquivos ser√£o respons√°veis por receber as requisi√ß√µes HTTP e direcion√°-las para as fun√ß√µes adequadas nos controladores. Nas rotas privadas inclua a fun√ß√£o **"verifyJWT"** que implementamos no controller.

- Lembre-se de chamar as rotas no arquivo "server.js".

````
import express from "express";
import { createUsuario, deleteCliente, getClienteByUser, loginCliente, verifyJWT } from "../Controller/usuario_controller.js";

const routerUsuario = express.Router()

routerUsuario.get("/usuario/:user",verifyJWT, getClienteByUser)
routerUsuario.post("/usuario/register", createUsuario)
routerUsuario.post("/usuario/login", loginCliente)
routerUsuario.delete("/usuario/:user", verifyJWT, deleteCliente)

export default routerUsuario
````
Note que estou utilizando as bibliotecas:

- "express" que √© um framework utilizado para desenvolvimento de aplica√ß√µes web em Node.js.
- "usuario_controller"  que cont√©m os m√©todos criados para controlar as funcionalidades relacionadas aos usu√°rios.

Neste exemplo, utilizo o "express" para a cria√ß√£o das minhas rotas. Elas s√£o configuradas usando o objeto "routerUsuario" e exportadas para serem utilizadas no arquivo "server.js" criado anteriormente.

### Implementando rotas no "server.js"

Para implementar suas rotas no servidor, voc√™ precisa import√°-las e utilizar o m√©todo "use" do Express para defini-las. 

Segue o exemplo:

````
import express from 'express'
import routerTutor from './Routes/tutor_routes.js'
import routerPet from './Routes/pet_routes.js'
import routerUsuario from './Routes/usuario_routes.js'
import db from './Config/database.js'

const server = express()
server.use(express.json())
server.use(express.urlencoded({ extended: true }))

//Rotas
server.use(routerUsuario)
server.use(routerPet)
server.use(routerTutor)

db.sync({ alter: true }).then(() => {
	console.log("Tabelas criadas no banco de dados")
}).catch(error => {
	console.error("Erro ao sincronizar os modelos com o banco de dados:", error)
})
server.listen(3000, function () {
	console.log('Sevidor rodando na porta 3000')
})
````

## Conclus√£o üéØ

Neste projeto, desenvolvemos uma aplica√ß√£o server-side no padr√£o MVC, utilizando tecnologias como Node.js, Sequelize, Json Web Token e Express.js. Aprendemos a configurar o ambiente de desenvolvimento, criar modelos de banco de dados, implementar funcionalidades nos controladores e proteger os endpoints com tokens de autentica√ß√£o. Essas habilidades adquiridas s√£o essenciais para construir APIs seguras e escal√°veis, demonstrando a import√¢ncia de estruturar corretamente uma aplica√ß√£o back-end.

### Desenvolvedores üë®‚Äçüíª

Cr√©ditos ao Leandro Pellegrini Fodi e V√≠tor de Oliveira Celestino da Silva





